# project5_b SM2 签名算法误用攻击分析与验证

## 概述
这个目录主要记录project5中b）任务的解决

b). 20250713-wen-sm2-public.pdf 中提到的关于签名算法的误用 分别基于做poc验证，给出推导文档以及验证代码

---

## SM2 签名算法数学背景

SM2 数字签名算法基于椭圆曲线密码学，使用国密推荐的椭圆曲线参数。  
在签名阶段，核心计算公式为：

1. 计算消息杂凑：
   \[ e = Hash(Z_A || M) \]
   其中 Z_A 包含用户标识、公钥等信息。

2. 生成随机数 \( k \)，计算椭圆曲线点：
   \[ (x_1, y_1) = k G \]

3. 计算：
   \[ r = (e + x_1) \bmod n \]

4. 计算：
   \[ s = (1 + d)^{-1} (k - r d) \bmod n \]

签名结果为：
\[ (r, s) \]

---

## 误用场景与攻击推导

### 1. 泄露 k

**已知条件**：签名 \((r, s)\) 以及随机数 \(k\)  
**目标**：恢复私钥 \(d\)

公式推导：
\[
s(1+d) = k - r d \\
s + s d = k - r d \\
d(s+r) = k - s \\
\boxed{d = (k - s) (s + r)^{-1} \bmod n}
\]

**实现思路**：攻击者只需一次签名中泄露的 k，即可直接计算私钥。

---

### 2. 同一私钥重复使用同一 k

**已知条件**：同一私钥 \(d\)，相同的 k，对不同消息签名得到 \((r_1, s_1)\)、\((r_2, s_2)\)  
**目标**：恢复私钥 \(d\)

公式推导：
\[
k = s_1 + d(s_1 + r_1) \\
k = s_2 + d(s_2 + r_2) \\
s_1 - s_2 = d(s_2 + r_2 - s_1 - r_1) \\
\boxed{d = (s_1 - s_2)(s_2 + r_2 - s_1 - r_1)^{-1} \bmod n}
\]

**实现思路**：重复使用 k 会导致两个线性方程，联立即可解出 d。

---

### 3. 不同用户共用同一 k

**已知条件**：用户 A 和 B 使用相同的 k 分别签名  
**攻击者能力**：用户 A 知道自己的私钥和签名  
**目标**：A 恢复 B 的私钥

公式推导：
对 A：
\[ k = s_A + d_A(s_A + r_A) \]
对 B：
\[ k - s_B = d_B(s_B + r_B) \]
因此：
\[ \boxed{d_B = (k - s_B)(s_B + r_B)^{-1} \bmod n} \]

**实现思路**：A 用自己的签名计算 k，再利用 B 的签名恢复 d_B。

---

## PoC 运行说明

本项目包含 4 个 PoC 脚本：
- `attack1.py`：泄露 k 恢复私钥
- `attack2.py`：同一私钥重复使用 k 恢复私钥
- `attack3.py`：不同用户共用 k 恢复对方私钥

运行示例：
```bash
python attack1.py
```

脚本会生成随机测试数据，并在最后断言恢复的私钥与真实值相同。

---

## 参考
- 20250713-wen-sm2-public.pdf
- 《SM2 椭圆曲线公钥密码算法》标准
