# project1:做SM4的软件实现和优化

## 一、任务概述

a): 从基本实现出发 优化SM4的软件执行效率，至少应该覆盖T-table、AESNI以及最新的指令集（GFNI、VPROLD等）
b): 基于SM4的实现，做SM4-GCM工作模式的软件优化实现

### 1.1 项目结构
```
project1/
├── sm4.h          # SM4基础类头文件
├── sm4.cpp        # SM4基础实现
├── sm4_ttable.h   # T-table优化头文件
├── sm4_ttable.cpp # T-table优化实现
├── sm4_gcm.cpp    # SM4-GCM模式实现
├── sm4_main.cpp       # 主程序与性能测试
└── README.md      # 项目说明文档
```

---

## 二、SM4算法数学原理与推导

### 2.1 算法基本参数

**分组长度**: 128位 (16字节)
**密钥长度**: 128位 (16字节)  
**轮数**: 32轮
**结构**: Feistel网络

### 2.2 数学符号定义

设明文分组为 M = (X₀, X₁, X₂, X₃)，其中每个 Xᵢ 为32位无符号整数。
设密钥为 K = (MK₀, MK₁, MK₂, MK₃)，其中每个 MKᵢ 为32位无符号整数。

### 2.3 轮密钥扩展算法

#### 2.3.1 系统参数

**FK参数**（用于密钥预处理）:
```
FK[0] = 0xa3b1bac6
FK[1] = 0x56aa3350  
FK[2] = 0x677d9197
FK[3] = 0xb27022dc
```

**CK参数**（轮常量）:
```
CK[i] = (4i + 7) × 0x01010101 mod 2^32, i = 0,1,...,31
```

#### 2.3.2 密钥扩展过程

**步骤1**: 密钥预处理
Kᵢ = MKᵢ ⊕ FKᵢ, i = 0,1,2,3

**步骤2**: 轮密钥生成（32轮）
Kᵢ₊₄ = Kᵢ ⊕ L'(Sbox(Kᵢ₊₁ ⊕ Kᵢ₊₂ ⊕ Kᵢ₊₃ ⊕ CKᵢ)), i = 0,...,31

其中：
- Sbox() 为8位S盒替换函数
- L'(B) = B ⊕ (B ≪≪ 13) ⊕ (B ≪≪ 23) 为线性变换函数
- ≪≪ 表示循环左移操作

**最终轮密钥**: rkᵢ = Kᵢ₊₄, i = 0,...,31

### 2.4 加密/解密轮函数

#### 2.4.1 轮函数结构

每轮迭代计算：
Xᵢ₊₄ = Xᵢ ⊕ L(Sbox(Xᵢ₊₁ ⊕ Xᵢ₊₂ ⊕ Xᵢ₊₃ ⊕ rkᵢ)), i = 0,...,31

其中：
- L(B) = B ⊕ (B ≪≪ 2) ⊕ (B ≪≪ 10) ⊕ (B ≪≪ 18) ⊕ (B ≪≪ 24) 为线性变换函数
- Sbox() 为8位S盒替换函数

#### 2.4.2 输出变换

经过32轮迭代后，最终输出为：
C = (X₃₅, X₃₄, X₃₃, X₃₂)

### 2.5 解密算法

解密过程与加密过程相同，但轮密钥使用顺序相反：
rk'ᵢ = rk₃₁₋ᵢ, i = 0,...,31

### 2.6 S盒设计原理

SM4的S盒是一个8×8的替换表，包含256个元素。S盒的设计遵循以下原则：
- 非线性度最大化
- 差分特性最优
- 线性特性最优
- 代数复杂度高

---

## 三、实现架构与设计思路

### 3.1 基础实现架构

#### 3.1.1 类设计
```cpp
class SM4 {
public:
    static const int BLOCK_SIZE = 16;  // 分组大小
    uint32_t rk[32];                  // 轮密钥数组
    static const uint8_t Sbox[256];    // S盒表
    static const uint32_t FK[4];       // FK参数
    static const uint32_t CK[32];      // CK参数
    
    // 核心方法
    void encryptBlock(const uint8_t in[16], uint8_t out[16]);
    void decryptBlock(const uint8_t in[16], uint8_t out[16]);
    void keySchedule(const uint8_t key[16]);
    
private:
    uint32_t tau(uint32_t A);          // S盒替换函数
    uint32_t l1(uint32_t B);           // 加密线性变换
    uint32_t l2(uint32_t B);           // 密钥扩展线性变换
};
```

#### 3.1.2 核心函数实现

**S盒替换函数**:
```cpp
uint32_t SM4::tau(uint32_t A) {
    uint8_t a[4];
    // 分解为4个字节
    a[0] = (A >> 24) & 0xFF;
    a[1] = (A >> 16) & 0xFF;
    a[2] = (A >> 8) & 0xFF;
    a[3] = A & 0xFF;
    
    // 逐字节S盒替换
    for (int i = 0; i < 4; ++i) {
        a[i] = SM4::Sbox[a[i]];
    }
    
    // 重新组合
    return ((uint32_t)a[0] << 24) | ((uint32_t)a[1] << 16) | 
           ((uint32_t)a[2] << 8) | a[3];
}
```

**线性变换函数**:
```cpp
uint32_t SM4::l1(uint32_t B) {
    return B ^ ((B << 2) | (B >> 30)) ^ 
           ((B << 10) | (B >> 22)) ^ 
           ((B << 18) | (B >> 14)) ^ 
           ((B << 24) | (B >> 8));
}
```

### 3.2 T-table优化实现

#### 3.2.1 优化原理

T-table优化的核心思想是将S盒替换和线性变换合并为查表操作，避免运行时的复杂计算。

#### 3.2.2 数学推导

设输入字节为 x，则T-table的构造为：
T[i][x] = L(Sbox(x) ≪ (24 - 8i)), i = 0,1,2,3

其中：
- i = 0: T[0][x] = L(Sbox(x) ≪ 24)
- i = 1: T[1][x] = L(Sbox(x) ≪ 16)  
- i = 2: T[2][x] = L(Sbox(x) ≪ 8)
- i = 3: T[3][x] = L(Sbox(x))

#### 3.2.3 实现代码

```cpp
void sm4_init_ttable() {
    if (ttable_inited) return;
    for (int i = 0; i < 256; ++i) {
        uint32_t x = SM4::Sbox[i];
        T[0][i] = L1(x << 24);    // 高字节
        T[1][i] = L1(x << 16);    // 次高字节
        T[2][i] = L1(x << 8);     // 次低字节
        T[3][i] = L1(x);          // 低字节
    }
    ttable_inited = true;
}
```

**优化后的轮函数**:
```cpp
void sm4_encrypt_ttable(const uint8_t in[16], uint8_t out[16], const uint32_t rk[32]) {
    // ... 初始化代码 ...
    for (int i = 0; i < 32; ++i) {
        uint32_t tmp = X[i + 1] ^ X[i + 2] ^ X[i + 3] ^ rk[i];
        // 使用T-table进行查表操作
        X[i + 4] = X[i] ^ (
            T[0][(tmp >> 24) & 0xFF] ^    // 高字节查表
            T[1][(tmp >> 16) & 0xFF] ^    // 次高字节查表
            T[2][(tmp >> 8) & 0xFF] ^     // 次低字节查表
            T[3][tmp & 0xFF]              // 低字节查表
        );
    }
    // ... 输出转换代码 ...
}
```

### 3.3 GCM模式实现

#### 3.3.1 GCM模式原理

GCM（Galois/Counter Mode）是一种认证加密模式，结合了：
- **CTR模式加密**: 提供机密性
- **GHASH认证**: 提供完整性认证

#### 3.3.2 数学基础

**GF(2¹²⁸)域运算**:
- 不可约多项式: P(x) = x¹²⁸ + x⁷ + x² + x + 1
- 域元素表示为128位二进制数
- 加法为异或运算
- 乘法为多项式乘法后模P(x)

**GHASH函数**:
GHASH(H, A, C) = Xₘ₊ₙ₊₁

其中：
X₀ = 0
Xᵢ = (Xᵢ₋₁ ⊕ Aᵢ) · H, i = 1,...,m
Xₘ₊ⱼ = (Xₘ₊ⱼ₋₁ ⊕ Cⱼ) · H, j = 1,...,n
Xₘ₊ₙ₊₁ = (Xₘ₊ₙ ⊕ (len(A) || len(C))) · H

#### 3.3.3 实现架构

```cpp
// GF(2^128)乘法实现
static u128 gfmul(const u128& X, const u128& Y) {
    u128 Z = {0, 0};
    u128 V = X;
    
    // 从MSB到LSB扫描Y的每一位
    for (int i = 0; i < 128; ++i) {
        // 检查Y的MSB
        uint64_t mask;
        int idx = i / 64;
        int shift = 63 - (i % 64);
        bool bit = ((Y[idx] >> shift) & 1);
        
        if (bit) {
            Z[0] ^= V[0];
            Z[1] ^= V[1];
        }
        
        // V右移1位，如果LSB为1则异或不可约多项式
        bool lsb = V[1] & 1;
        V = shl1(V);
        if (lsb) {
            V[0] ^= 0xE1;  // 0xE1 << 120
        }
    }
    return Z;
}
```

---

## 四、性能分析与优化效果

### 4.1 性能测试结果

```text
基础版加密后密文: 681edf34d206965e86b3e94f536e4246
基础版解密后明文: 0123456789abcdeffedcba9876543210
T-table优化加密后密文: 681edf34d206965e86b3e94f536e4246
T-table优化解密后明文: 0123456789abcdeffedcba9876543210
===== 加解密效率对比（1000000轮）=====
基础版加密 1000000 次耗时: 1122.23 毫秒, 速度: 891085 块/秒
T-table优化加密 1000000 次耗时: 201.415 毫秒, 速度: 4,964,870 块/秒
基础版解密 1000000 次耗时: 1085.99 毫秒, 速度: 920,818 块/秒
T-table优化解密 1000000 次耗时: 193.572 毫秒, 速度: 5,166,040 块/秒
```

| 算法        | 加密耗时(ms) | 加密速度(块/秒) | 解密耗时(ms) | 解密速度(块/秒) |
| ----------- | ------------ | --------------- | ------------ | --------------- |
| 基础版      | 1122.23      | 891,085         | 1085.99      | 920,818         |
| T-table优化 | 201.415      | 4,964,870       | 193.572      | 5,166,040       |

- T-table优化比基础版快约5~6倍，极大提升了加解密效率。
